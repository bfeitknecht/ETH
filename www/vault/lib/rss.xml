<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[vault]]></title><description><![CDATA[Obsidian digital garden]]></description><link>https://n.ethz.ch/~bfeitknecht/</link><image><url>https://n.ethz.ch/~bfeitknecht/lib/media/favicon.png</url><title>vault</title><link>https://n.ethz.ch/~bfeitknecht/</link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Tue, 20 Feb 2024 14:42:28 GMT</lastBuildDate><atom:link href="https://n.ethz.ch/~bfeitknecht/lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Tue, 20 Feb 2024 14:42:13 GMT</pubDate><copyright><![CDATA[Basil Feitknecht]]></copyright><ttl>60</ttl><dc:creator>Basil Feitknecht</dc:creator><item><title><![CDATA[java-algorithms]]></title><description><![CDATA[ 
 <br>public void BFS(int s) { // only runs on G with weights of 1
  int[] distance = new int[n]; // distances from s
  for (int i = 0; i &lt; n; i++) distance[i] = -1; // populate distances
  Queue&lt;Integer&gt; Q = new LinkedList&lt;Integer&gt;(); 
  Q.add(s); // add source to queue
  distance[s] = 0; // distance from s -&gt; s = 0
  visited[s] = true;
  while (!Q.isEmpty()) { // iterate until queue empty
    int u = Q.poll(); // next vertex is polled
    for (int i = 0; i &lt; degree[u]; i++) { // for all neighbors to u
      if (distance[edges[u][i]] == -1) { // if not visited
        distance[edges[u][i]] = distance[] + 1; // update distances
        Q.add(edges[u][i); // add i-th neighbor to queue
      }
    }
  }
}

public void DFS(int s) {
  visited[s] = true; // visited array
  for (int i = 0; i &lt; degree[s]; i++) { // for each neighbor
    if (!visited[edges[s][i]]) { // if not visited
    //set[edges[s][i]] = set[s]; // for computing sets in graph
    DFS(edges[s][i]); // recursive call to i-th child
    }
  }
}

public void dijkstra(int s) {
  int[] distance = new int[n]; // distance to all other v in G
  Arrays.fill(distance, Integer.MAX_VALUE); // fill with "infinity"
  Queue&lt;Integer&gt; Q = new LinkedList&lt;&gt;(); // queue for BFS
  Q.add(s); // initialize queue with the source
  distance[s] = 0; // distance from s -&gt; s = 0
  while (!Q.isEmpty()) { // iterate until queue empty
    int u = Q.poll(); // u is top node in Q
    for (int i = 0; i &lt; Av.get(u).size(); i++) { // check each child of u
      int v = Av.get(u).get(i); // child v
      int c = Aw.get(u).get(i); // weight of (u, v)
      // update distance if shorter path found
      if (distance[u] + w &lt; distance[v]) {
        distance[v] = distance[u] + c;
        Q.add(v);
      }
    }
  }
}

public int prim(int s) {
  int[] distance = new int[n]; // distance to all other v in MST
  Arrays.fill(distance, Integer.MAX_VALUE); // fill with "infinity"
  PriorityQueue&lt;Integer&gt; PQ = new PriorityQueue&lt;&gt;(); // for selecting minimum edge
  PQ.add(s);
  distance[s] = 0;
  while (!PQ.isEmpty()) {
    int u = PQ.poll();
    for (int i = 0; i &lt; Av.get(u).size(); i++) {
      int v = Av.get(u).get(i);
      int c = Aw.get(u).get(i);
      if (w &lt; distance[v]) {
        distance[v] = c;
        PQ.add(v);
      }
    }
  }
  int sum = 0;
  for (int dist : distance) sum += dist;
  return sum;
}



public static int getMaximumScore(int n, int[] A) { // left-right game
  int[][] DP = new int[n][n];
  for (int s = 2; s &lt;= n; s++) {
    for (int i = 0; i &lt; n - s + 1; i++) {
      int j = i + s - 1;
      if (s == 2) DP[i][j] = Math.abs(A[i] - A[j]);
      else DP[i][j] = Math.max(Math.max(DP[i+1][j], DP[i][j-1]),
						       Math.abs(A[i] - A[j]) + DP[i+1][j-1]);
	}
  }
  return DP[0][n-1];
}

public static int ShortestUncommonSubsequence(int n, int m, char[] A, char B[]) {
  int[][] DP = new int[n + 1][m + 1];
  for (int i = 0; i &lt;= n; i++) DP[i][0] = 1;
  for (int j = 0; j &lt;= m; j++) DP[0][j] = Integer.MAX_VALUE - 1;
  for (int i = 1; i &lt;= n; i++) {
    for (int j = 1; j &lt;= m; j++) {
      char common = A[i - 1];
      int search;
      for (search = j - 1; search &gt;= 0; search--) if (B[search] == common) break;
      if (search == -1) DP[i][j] = 1; 
      else {
        if (DP[i - 1][j] &lt;= DP[i - 1][search] + 1) DP[i][j] = DP[i - 1][j];
        else DP[i][j] = DP[i - 1][search] + 1;
      }
    }
  }
  if (DP[n][m] &lt; Integer.MAX_VALUE) return DP[n][m];
  else return -1;
}








Copy]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/AuD/00-EXAM-PREP/summaries/java-algorithms.html</link><guid isPermaLink="false">sem1/AuD/00-EXAM-PREP/summaries/java-algorithms.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:20 GMT</pubDate></item><item><title><![CDATA[AuD_lib]]></title><description><![CDATA[ 
 ]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/AuD/lib/AuD_lib.html</link><guid isPermaLink="false">sem1/AuD/lib/AuD_lib.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:21 GMT</pubDate></item><item><title><![CDATA[AuD-u00-bf]]></title><description><![CDATA[ 
 <br><br>We want to prove that for all positive integers ,<br><br><br>When , we have<br><br>This is true, so the base case holds.<br><br>Assume that the formula holds for some positive integer . That is,<br><br><br>We will show that if the formula holds for , it also holds for . Starting with the assumption from the inductive hypothesis,<br><br>Now, add  to both sides:<br><br>Using the assumption from the inductive hypothesis:<br><br>Simplify the left side:<br><br>Factor out  from the left side:<br><br>Since the left side is equal to the right side, we have shown that if the formula holds for , it also holds for .<br><br>By mathematical induction, we have proven that<br><br>for all positive integers .]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/AuD/UE/bf/md/AuD-u00-bf.html</link><guid isPermaLink="false">sem1/AuD/UE/bf/md/AuD-u00-bf.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:21 GMT</pubDate></item><item><title><![CDATA[AuD-u07-bf]]></title><description><![CDATA[ 
 <br><a data-tooltip-position="top" aria-label="sem1/AuD/VRL/V14_" data-href="sem1/AuD/VRL/V14_" href="https://n.ethz.ch/~bfeitknecht/sem1/AuD/VRL/V14_.html" class="internal-link" target="_self" rel="noopener">V14_</a><br>7.1<br>int[] A;
int n = A.length;
int b;
boolean[][] dp = new boolean [n+1][b+1];

// base cases; 0 can always sum up to zero
for (int i = 0; i &lt;= n; i++) {dp[i][0] = true;}

for(int i = 1; i &lt;= n; i++) { //loop through rows (1-n)
	for(int j = 1; j &lt;= b; j++) { //loop through columns (1-b)
		// guard arm for cases where A[i] can be reached already
		dp[i][j] = dp[i-1][j];
		
		if (j &gt;= A[i-1]) {
			// using A[i] once, i.e. base cases
			dp[i][j] |= dp[i-1][j - A[i-1]];
			
			// using A[i] three times
			dp[i][j] |= dp[i-1][j - 3 * A[i-1]];
		}
	}
}
return dp[n][b]

Copy<br>
<br>
Dimensions of the DP table: What are the dimensions of the DP table?<br>
The dimensions are n+1 by b+1, that is one row for every element in A and one row for all numbers to b, plus one row and column for zero. 

<br>
Subproblems: What is the meaning of each entry?<br>
Each entry represents the possibility of achieving the j with the subset A[1, i] or the addition of j or 3*j.

<br>
Recursion: How can an entry of the table be computed from previous entries? Justify why your recurrence relation is correct. Specify the base cases of the recursion, i.e., the cases that do not depend on others.<br>
If j can be reached with A[i] or 3*A[i], the cell is set to true. These are the base cases.   

<br>
Calculation order: In which order can entries be computed so that values needed for each entry have been determined in previous steps?<br>
Each entry is calculated, row after row. All entries are either trivial (A[i] or 3*A[i]) or a combination of previous entries.

<br>
Extracting the solution: How can the solution be extracted once the table has been filled?<br>
The value of dp[n][b] will tell if there exists a subset , such that , where .

<br>
Running time: What is the running time of your solution?<br>
The running time is O(n*b) since<br>
a. The outer loop runs from 1 to n, and the inner loop runs from 1 to b. Each iteration of the inner loop involves constant time operations.
b. Inside the inner loop, there are constant-time operations for checking conditions and updating the DP table.

<br>7.4<br>int[][][] DP = new int[n + 1][k + 1][2];

// Base cases
for (int l = 0; l &lt;= 1; l++) {
	DP[1][0][l] = 1;
}

// Filling the DP table
for (int i = 2; i &lt;= n; i++) {
	for (int j = 0; j &lt;= k; j++) {
		for (int l = 0; l &lt;= 1; l++) {
			DP[i][j][l] = DP[i - 1][j][0] + DP[i - 1][j][1];
			if (j &gt; 0) { DP[i][j][l] += DP[i - 1][j - 1][l];
			}
		}
	}
}
// Summing up the possibilities for the last character
int result = DP[n][k][0] + DP[n][k][1];
return result;
Copy<br>
<br>
<br>
<br>i represents the length of the binary string.
<br>j represents the number of occurrences of "11" in the string.
<br>l represents the last digit of the string (either 0 or 1).
<br>
<br>
The entry DP[i][j][l] represents the number of binary strings of length i with j occurrences of "11" that end in l.

<br>
The recurrence relation is given by:<br>
DP[i][j][l] = DP[i-1][j][0] + DP[i-1][j][1] + DP[i-1][j-1][l]<br>
This relation considers the possibilities of appending a 0 or a 1 to the existing strings and accounts for the occurrence of "11." The base cases are:

<br>
<br>DP[1][0][0] = 1
<br>DP[1][0][1] = 1
<br>
<br>
The entries can be computed in a bottom-up manner. The outer loop iterates over the length of the string (i), the middle loop over the number of occurrences (j), and the inner loop over the last digit (l).

<br>
Once the DP table is filled, the solution is obtained by summing up the possibilities for the last character of the string:<br>
result = DP[n][k][0] + DP[n][k][1];

<br>
The running time of the solution is O(nk). This is because the algorithm involves a triple-nested loop structure, where each loop can iterate up to n, k, and 2 respectively. The filling of the DP table and the final computation of the result both have a time complexity of O(nk).

]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/AuD/UE/bf/md/AuD-u07-bf.html</link><guid isPermaLink="false">sem1/AuD/UE/bf/md/AuD-u07-bf.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:21 GMT</pubDate></item><item><title><![CDATA[AuD-u08-bf]]></title><description><![CDATA[ 
 <br><br>In this exercise, we want to prove the following statement: Among any six people, there are either three that all know each other or three that all do not know each other (or both). We assume that this relation is symmetric, so if person  knows person , then also  knows . We model the problem as a graph. We define  to be a graph on 6 vertices, where the vertices correspond to the six people and two people are connected by an edge if they know each other.<br>a)<br>
Prove the above statement, i.e. that in every possible graph on 6 vertices, there are three vertices that are all pairwise adjacent or there are three vertices that are all pairwise not adjacent.<br>We will prove this using case distinction. Let's imagine the graph  with the six vertices {a, b, c, d, e, f}. To model the edges, we will utilise an adjacency table, where each column represent a vertex and the rows contain its degree, i.e. what other vertices it's connected to. since we don't want to count edges twice (symetry) and a vertex can't be connected to itself, the matrix looks like this, for the cases where everyone knows everyone and no one knows anybody, respectively:<br><br><br>we note that for any three people to not know each other means, that there exists a cycle between their respective vertices, so for example  knows ,  knows , and  knows  (and of course vice versa). we can denote this property as follows: if two people know each other, find a third who they both know. that is a cycle between three friends. if we start randomly adding edges, we note, that there always a set of two vertices, together with a third, that are all not connected until we reach 6 edges. at this point however, the only way for there to not be a cycle of strangers, there must be two cycles already. after we add four more, we note that there must now exist at least one cycle between three vertices. that is because at nine edges every vertex must be connected to at least two other vertex, and thus, no matter where we draw the tenth edge, a cycle will close.<br><br>b)<br>
Is the statement also true for five people? In other words, does the following hold: For any graph  with 5 vertices, there are either three vertices that are all pairwise adjacent or there are three vertices that are all pairwise not adjacent (or both). Provide a proof or a counterexample.<br>disproven by counterexample. observe the adjacency table for the following graph:<br><br>since it's not possible to find two unconnected vertices with a third that isn't connected to either, but there's also no closed cycle between three vertices, the statement is disproven.<br><br><br><br>In the following, let  be a graph,  and .<br>a)<br>
Let . Prove that if there is a walk with endpoints  and , then there is a path with endpoints  and .<br>Proof:<br>
Let's assume that there is a walk with endpoints  and . A walk is a sequence of vertices where consecutive vertices are connected by edges, and it may revisit vertices. We want to show that there exists a path with endpoints  and . If the walk has repeated vertices, we can remove the repeated vertices while keeping the edges between them. This operation does not change the fact that it's a walk but turns it into a path if there are no repeated vertices. Thus, we obtain a path with endpoints  and .<br><br>b)<br>
Every graph with &lt; is connected.<br>False:<br>
Consider a disconnected graph with two separate components, each having one vertex. The number of vertices  is 2, and the number of edges  is 0. Here, , but the graph is not connected.<br><br>c)<br>
If  contains a Hamiltonian path, then  contains a Eulerian walk.<br>False:<br>
A Hamiltonian path visits each vertex exactly once. An Eulerian walk, on the other hand, visits each edge exactly once. Not every Hamiltonian path traverses each edge exactly once, so the statement is false. Consider a path graph with three vertices; it has a Hamiltonian path but not an Eulerian walk.<br><br>d)<br>
If every vertex of a non-empty graph  has degree at least 2, then  contains a cycle.<br>True:<br>
If every vertex has degree at least 2, then you can start at any vertex, move to a neighbor, then to another neighbor, and so on. Since every vertex has at least two neighbors, at some point, you must revisit a vertex, forming a cycle.<br><br>e)<br>
Suppose in a graph  every pair of vertices ,  has a common neighbour (i.e., for all distinct vertices , , there is a vertex x such that  and  are both edges). Then there exists a vertex  in  which is a neighbour of every other vertex in  (i.e.,  has degree ).<br>True:<br>
Since every pair of vertices has a common neighbor, you can construct a graph where one vertex is connected to all other vertices. Let  be that vertex. It is a common neighbor for every pair of vertices, and therefore, it has degree .<br><br>f)<br>
Let  be a connected graph with at least 3 vertices. Suppose there exists a vertex  in  so that after deleting ,  is no longer connected. Then  does not have a Hamiltonian cycle. (Deleting a vertex v means that we remove v and any edge containing v from the graph)<br>True:<br>
If cutting one edge between two vertices in a connected graph of at least three vertices results in a disconnected graph, then the original graph cannot have a Hamiltonian cycle.<br>A Hamiltonian cycle in a graph is a cycle that visits every vertex exactly once and returns to the starting vertex. If cutting a single edge makes the graph disconnected, it means that there is no longer a path between the two components created by the removal of the edge. Therefore, a Hamiltonian cycle cannot exist in the original graph, as it would require a cycle that visits every vertex, and cutting one edge would break the cycle.]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/AuD/UE/bf/md/AuD-u08-bf.html</link><guid isPermaLink="false">sem1/AuD/UE/bf/md/AuD-u08-bf.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:21 GMT</pubDate></item><item><title><![CDATA[AuD-u09-bf]]></title><description><![CDATA[ 
 <br><br>(a)<br>
If for every vertex  its in-degree  is even, then  is even.<br>Proof:<br>
This statement is true. Consider any directed graph G = (V, E) where every vertex v has an even in-degree. We can count the number of edges by summing up the in-degrees of all vertices because each edge contributes to the in-degree of one vertex. Since every in-degree is even, the sum of all in-degrees is even. This implies that the number of edges |E| is also even.<br><br>(b)<br>
For a longest directed path  in , the endpoint has to be a sink.<br>Proof:<br>
This statement is true. Let's assume, for the sake of contradiction, that the longest directed path P has an endpoint vₗ that is not a sink. Since vₗ is not a sink, it must have an outgoing edge. However, this would contradict the maximality of the path P because if we add the outgoing edge from vₗ to the path, we would obtain a longer path, which contradicts the assumption that P is the longest path. Therefore, the endpoint vₗ must be a sink.<br>This completes the proof, demonstrating that in a directed graph, the endpoint of the longest directed path must be a sink.<br><br>(b)<br>
The following graph has a topological sorting. If so, give a topological sorting; if not, prove why no topological sorting can exist.<br><br>To find a topological sorting, we can use the following algorithm:<br>
<br>Identify any vertex with in-degree 0 (a vertex with no incoming edges) and add it to the sorting.
<br>Remove the chosen vertex and its outgoing edges from the graph.
<br>Repeat steps 1-2 until all vertices are in the sorting.
<br>If we successfully perform these steps, we have a topological sorting. If at any point no vertex with in-degree 0 exists, and there are still vertices remaining in the graph, then no topological sorting is possible.<br>Let's apply this algorithm to the given graph:<br>
<br>Choose G (in-degree 0), remove G and its outgoing edges.
<br>Choose E (in-degree 0), remove E and its outgoing edges.
<br>Choose C (in-degree 0), remove C and its outgoing edges.
<br>Choose D (in-degree 0), remove D and its outgoing edges.
<br>Choose A (in-degree 0), remove A and its outgoing edges.
<br>Choose H (in-degree 0), remove H and its outgoing edges.
<br>Choose F (in-degree 0), remove F and its outgoing edges.
<br>Choose I (in-degree 0), remove I and its outgoing edges.
<br>Choose B (in-degree 0), remove B and its outgoing edges.
<br>The resulting topological sorting is: G, E, C, D, A, H, F, I, B.<br>Therefore, the given graph has a topological sorting.<br><br><br>Let  be a directed graph without directed cycles (i.e., a directed acyclic graph or short DAG). Assume that  . Further assume that  is a source and  is a sink. The goal of this exercise is to find the number of paths from  to .<br>(a)<br>
Prove that there exists a topological sorting of G that has  as first and  as last vertex.<br>Proof:<br>
To prove that there exists a topological sorting of  that has ​ as the first vertex and ​ as the last vertex, we can use the properties of a directed acyclic graph (DAG) and the fact that ​ is a source and ​ is a sink.<br>Since  is a DAG, it has a topological ordering. Let's consider a topological ordering , where  represents the position of vertex ​ in the topological ordering.<br>Since  is a source, it has no incoming edges. Therefore, in the topological ordering,   must come before any vertex  ​where . In other words,  for all .<br>Similarly, since ​ is a sink, it has no outgoing edges. Therefore, in the topological ordering, ​ must come after any vertex ​ where . In other words,  for all .<br>Now, let's consider the vertices between  and , i.e.  Since  is a DAG, there are no cycles, so there must be a directed path from  to  that goes through these intermediate vertices. Therefore, in the topological ordering,  comes before , which comes before , and so on, until , which comes before .<br>Thus we have a topological ordering where ​ is the first vertex, ​ is the last vertex, and the vertices in between are ordered according to the topological ordering. This proves the existence of such a topological sorting for .<br><br>(b)<br>
Prove that for any directed -path  we have .<br>Proof:<br>
Assume, for the sake of contradiction, that there exists a directed path  where ​ for some  (i.e., the indices are not strictly increasing).<br>Consider the first occurrence of ​ in the path. This means that there is an edge from  to ​, creating a subpath ​. Since ​, this subpath forms a cycle.<br>However, this contradicts the assumption that the graph is a directed acyclic graph (DAG). In a DAG, there cannot be any cycles. Therefore, our assumption that there exists ​ is false.<br>Since ​ is false, ​ is false, and so on, it follows that ​.<br>Therefore, for any directed -path , the indices of the vertices along the path are strictly increasing.<br><br>(c)<br>
Describe a bottom-up dynamic programming algorithm that, given a graph G with the property that v1, . . . , vn is a topological sorting, returns the number of v1-vn paths in G in O(|V | + |E|) time. You can assume that the graph is provided to you as a pair (n, Adj) of the integer n = |V | and the adjacency lists Adj. Your algorithm can access Adj[u], which is a list of vertices to which u has a direct edge, in constant time. Formally, Adj[u] := {v ∈ V | (u, v) ∈ E}.<br>In your solution, address the following aspects:<br>
<br>Dimensions of the DP table: What are the dimensions of the DP table?
<br>Subproblems: What is the meaning of each entry?
<br>Recursion: How can an entry of the table be computed from previous entries? Justify why your recurrence relation is correct. Specify the base cases of the recursion, i.e., the cases that do not depend on others.
<br>Calculation order: In which order can entries be computed so that values needed for each entry have been determined in previous steps?
<br>Extracting the solution: How can the solution be extracted once the table has been filled?
<br>Running time: What is the running time of your solution? Hint: Define the entry of the DP table as DP [i] = number of paths in G from vi to vn
<br>Solution:<br>1. Dimensions of the DP Table:<br>
The DP table will be a 1D array, DP, of size  where . <br>2. Subproblems:<br>
Each entry  represents the number of paths from vertex  to  in the graph.<br>3. Recursion:<br>
The recurrence relation for computing  from previous entries is as follows:<br>
<br>
This means that the number of paths from  to  is the sum of the number of paths from each vertex  in the adjacency list of  to .<br>Base Cases:<br>
 because there is only one path from  to , which is the vertex itself.<br>4. Calculation Order:<br>
We fill in the DP table in a bottom-up manner, starting from the last vertex  and moving towards the first vertex . This ensures that when we calculate , all the necessary values  for  have already been computed.<br>5. Extracting the Solution:<br>
The solution is given by , which represents the number of paths from  to .<br>6. Running Time:<br>
The running time of the solution is  since we visit each vertex once and each edge once while filling in the DP table.<br>Here's the Python code for the algorithm:<br>def count_paths(n, Adj):
    DP = [0] * (n + 1)

    # Base case
    DP[n] = 1

    # Bottom-up calculation
    for i in range(n - 1, 0, -1):
        for j in Adj[i]:
            DP[i] += DP[j]

    return DP[1]  # Number of paths from v1 to vn
Copy<br>In this code, Adj is the adjacency list representation of the graph, where Adj[i] is the list of vertices to which  has a direct edge.<br><br><br>Let  be a directed graph with n vertices and m edges. We say two distinct vertices  are strongly connected if there exists both a directed path from  to , and from  to . Describe an algorithm which finds a pair  of strongly connected vertices in , or decides that no such pair exists. The runtime of your algorithm should be at most . You are provided with the number of vertices , and the adjacency list  of .<br>
Hint: Use DFS as a subroutine<br>Solution:<br>
<br>
Compute the Reverse Graph:

<br>Create a new graph  with the same vertices as  but with reversed edges (directions inverted). For each edge  in , add the edge  to .


<br>
Run DFS on  to Compute Finishing Times:

<br>Perform a DFS on  to compute finishing times for each vertex. This is typically done by assigning a timestamp to each vertex when it finishes exploration in the DFS. Sort the vertices based on their finishing times in decreasing order.


<br>
Run DFS on  to Identify SCCs:

<br>Starting from the vertex with the highest finishing time obtained in the previous step, run DFS on  in the order of decreasing finishing times.
<br>Each DFS call from an unvisited vertex in this step identifies a new strongly connected component.


<br>
Identify a Pair of Vertices in the Same SCC:

<br>During the DFS in step 3, check for the existence of a back edge (an edge that goes back to a vertex already in the current DFS call stack). If such a back edge is found, the vertices involved in the back edge are in the same SCC.
<br>Output the pair of vertices involved in the back edge as a strongly connected pair.


<br>This algorithm ensures that the vertices involved in a back edge during the DFS on  are strongly connected. The runtime of the algorithm is , where  is the number of vertices, and  is the number of edges.<br>Here's a Python-like pseudocode for the algorithm:<br>def kosaraju_algorithm(n, Adj):
    def dfs(graph, vertex, visited, stack):
        visited[vertex] = True
        for neighbor in graph[vertex]:
            if not visited[neighbor]:
                dfs(graph, neighbor, visited, stack)
        stack.append(vertex)

    def dfs_scc(graph, vertex, visited, scc):
        visited[vertex] = True
        scc.append(vertex)
        for neighbor in graph[vertex]:
            if not visited[neighbor]:
                dfs_scc(graph, neighbor, visited, scc)

    # Step 1: Compute the Reverse Graph
    G_rev = {i: [] for i in range(1, n + 1)}
    for i in range(1, n + 1):
        for neighbor in Adj[i]:
            G_rev[neighbor].append(i)

    # Step 2: Run DFS on G_rev to Compute Finishing Times
    visited = [False] * (n + 1)
    stack = []
    for i in range(1, n + 1):
        if not visited[i]:
            dfs(G_rev, i, visited, stack)

    # Step 3: Run DFS on G to Identify SCCs
    visited = [False] * (n + 1)
    strongly_connected_pairs = []
    while stack:
        vertex = stack.pop()
        if not visited[vertex]:
            scc = []
            dfs_scc(Adj, vertex, visited, scc)
            if len(scc) &gt; 1:
                strongly_connected_pairs.append((scc[0], scc[1]))

    return strongly_connected_pairs

# Example usage:
n = 5
Adj = {1: [2], 2: [3], 3: [1, 4], 4: [5], 5: [3]}
result = kosaraju_algorithm(n, Adj)
print(result)
Copy<br>This pseudocode demonstrates the essential steps of Kosaraju's algorithm to find strongly connected pairs in a directed graph.]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/AuD/UE/bf/md/AuD-u09-bf.html</link><guid isPermaLink="false">sem1/AuD/UE/bf/md/AuD-u09-bf.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:21 GMT</pubDate></item><item><title><![CDATA[AuD-u11-bf]]></title><description><![CDATA[ 
 <br><br><br><br>A) enter: 1, leave: 2<br>
C) enter: 3, leave: 6<br>
F) enter: 4, leave: 10<br>
G) enter: 5, leave: 12<br>
D) enter: 7, leave: 13<br>
E) enter: 8, leave: 14<br>
H) enter: 9, leave: 15<br>
B) enter: 11, leave: 16<br><br><br>A-&gt;B: 2<br>
A-&gt;C: 1<br>
A-&gt;D: 2<br>
A-&gt;E: 2<br>
A-&gt;F: 1<br>
A-&gt;G: 1<br>
A-&gt;H: 2<br>
A-&gt;I: <br><br><br>ACFGDEHB<br>
ACFGDEHB<br><br><br>1 A<br>
2 A<br>
3 C<br>
4 F, C<br>
5 F, G, C<br>
6 F, G, C<br>
7 F, G, D<br>
8 F, G, D, H<br>
9 F, G, D, H<br>
10 F, G, D, H<br>
11 G, D, H, B<br>
12 G, D, H, B<br>
13 D, H, B<br>
14 B, H, E<br>
15 B, H<br>
16 B<br>
17<br>
18<br><br><br>]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/AuD/UE/bf/md/AuD-u11-bf.html</link><guid isPermaLink="false">sem1/AuD/UE/bf/md/AuD-u11-bf.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:21 GMT</pubDate></item><item><title><![CDATA[V00_AuD]]></title><description><![CDATA[ 
 ]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/AuD/VRL/V00_AuD.html</link><guid isPermaLink="false">sem1/AuD/VRL/V00_AuD.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:21 GMT</pubDate></item><item><title><![CDATA[V01_karatsuba, pasture-break]]></title><description><![CDATA[<a class="tag" href="https://n.ethz.ch/~bfeitknecht/?query=tag:Algorithm" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Algorithm</a> <a class="tag" href="https://n.ethz.ch/~bfeitknecht/?query=tag:Karatsuba" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Karatsuba</a> <a class="tag" href="https://n.ethz.ch/~bfeitknecht/?query=tag:School-Multiplication" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#School-Multiplication</a> <a class="tag" href="https://n.ethz.ch/~bfeitknecht/?query=tag:Pasture-Break" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Pasture-Break</a> 
 <br><br><br><br>]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/AuD/VRL/V01_karatsuba, pasture-break.html</link><guid isPermaLink="false">sem1/AuD/VRL/V01_karatsuba, pasture-break.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:21 GMT</pubDate></item><item><title><![CDATA[V02_big-O, star-search]]></title><description><![CDATA[<a class="tag" href="https://n.ethz.ch/~bfeitknecht/?query=tag:big-O-notation" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#big-O-notation</a> <a class="tag" href="https://n.ethz.ch/~bfeitknecht/?query=tag:aktien-kursveränderung" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#aktien-kursveränderung</a> 
 <br><br>Beschreibung
Star: kennt keine andere Person<br>
Normie: kennt Star
<br>Ziel:
unter n Personen (); , , , ..., , Star finden (falls da), mit möglichst wenigen fragen.<br>

<br>Naiv:
alle  fragen!<br>
n*(n-1) elementare operationen
<br>rekursiver Ansatz:
n  3

<br>finde "Star"  unter  ... 
<br>teste, ob  auch Star ist für  ...   (+2 Fragen}
<br>teste, ob  Star ist für  ...   (+2 Fragen)

best case: (nie Schritt 3)
worst case: (immer Schritt 3)
<br><br><br>+7 -11 +18 +10 -23 -3 +27 -1<br>höchste gewinne: +18+10-23-3+27= +29<br>problem: max subarray sum (MSS)<br>eingabe: <br>naiver algorithmus:<br>
<br>berechne alle teilsummen
<br>pseudocode:<br>
for (i: 1..n)<br>
<br>
<br>
<br>
<br>
<br>
endfor<br>A(n) = Anzahl Additionen (worst case)<br>
<br> Abschätzung (lower und upper bound)<br><br>
<br><br>
<br>
<br>Geht's besser??<br>
Natürlich!<br>
Assoziativität von Addition ausnutzen:<br>
for (i: 1..n)<br>
<br>
<br>
<br>
<br>
<br>
endfor<br>MSS rekursiv]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/AuD/VRL/V02_big-O, star-search.html</link><guid isPermaLink="false">sem1/AuD/VRL/V02_big-O, star-search.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:21 GMT</pubDate></item><item><title><![CDATA[V04_]]></title><description><![CDATA[<a class="tag" href="https://n.ethz.ch/~bfeitknecht/?query=tag:notyet" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#notyet</a> 
 <br><a href="https://n.ethz.ch/~bfeitknecht?query=tag:notyet" class="tag" target="_blank" rel="noopener">#notyet</a> ]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/AuD/VRL/V04_.html</link><guid isPermaLink="false">sem1/AuD/VRL/V04_.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:21 GMT</pubDate></item><item><title><![CDATA[V07_]]></title><description><![CDATA[<a class="tag" href="https://n.ethz.ch/~bfeitknecht/?query=tag:Dynamic-Programming" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Dynamic-Programming</a> <a class="tag" href="https://n.ethz.ch/~bfeitknecht/?query=tag:Memoization" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Memoization</a> 
 <br><br>Problem aufteilen in Teilprobleme und Werte zur Wiederverwendung speichern <a href="https://n.ethz.ch/~bfeitknecht?query=tag:Memoization" class="tag" target="_blank" rel="noopener">#Memoization</a>.]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/AuD/VRL/V07_.html</link><guid isPermaLink="false">sem1/AuD/VRL/V07_.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:21 GMT</pubDate></item><item><title><![CDATA[DMath]]></title><description><![CDATA[ 
 ]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/DMath/lib/DMath.html</link><guid isPermaLink="false">sem1/DMath/lib/DMath.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:21 GMT</pubDate></item><item><title><![CDATA[DMath_lib]]></title><description><![CDATA[ 
 ]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/DMath/lib/DMath_lib.html</link><guid isPermaLink="false">sem1/DMath/lib/DMath_lib.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:21 GMT</pubDate></item><item><title><![CDATA[DMath-u01-bf]]></title><description><![CDATA[ 
 <br><br><br>a)<br>
i) <br>
ii) <br>i) if mario is not getting evicted then he did not forget to pay his rent.<br>
ii) either Mario forgot his rent and is getting evicted or he did not forget to pay his rent and is not getting evicted.<br><br><br><br><br>(A  B)  C  A  (B  C)<br>
q.e.d.  <br><br><br><br>A  B  (A  B)<br>
q.e.d.  <br><br><br>truth table of F:<br><br>truth table of G:<br><br>F  A  (A  B)  ((A  B)  C)<br>
q.e.d.  <br><br><br><br>Thus we have proven, that <br>
]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/DMath/UE/bf/md/DMath-u01-bf.html</link><guid isPermaLink="false">sem1/DMath/UE/bf/md/DMath-u01-bf.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:21 GMT</pubDate></item><item><title><![CDATA[DMath-u06-bf]]></title><description><![CDATA[ 
 <br><a data-href="V10_posets" href="https://n.ethz.ch/~bfeitknecht/sem1/DMath/VRL/V10_posets.html" class="internal-link" target="_self" rel="noopener">V10_posets</a><br><br><br>Prove:<br>
Let A, B be sets. If A is uncountable and A  B then B is uncountable.<br>Proof:<br>
(using Lemma 3.15.(ii): The relation  is transitive: )<br>
(using Definition 3.42.(iii): A set  is called countable if , and uncountable otherwise)<br><br>
<br><br>Prove:<br>
The set  is uncountable.<br>Proof:<br>
We will prove this using contradiction. Let's assume the set  is countable, so . This means, that there is a one to one mapping onto each unique value (bijection) between functions  to . Let us define  as follows:<br><br>
For some <br>Let  be the i-th bit in the n-th sequence  where for convenience we begin numbering the bits with .<br>Let  be the complement of a bit .<br>We define a new semi-infinite binary sequence  as follows:<br>
<br>Obviously,  but there is no  such that  since  is constructed so as to disagree in at least one bit (actually the i-th bit) with every sequence  for . This shows that there cannot be an bijection from  to , which concludes the proof. We have shown that  and  is thus uncountable using Cantor's diagonalization argument.<br>
]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/DMath/UE/bf/md/DMath-u06-bf.html</link><guid isPermaLink="false">sem1/DMath/UE/bf/md/DMath-u06-bf.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:21 GMT</pubDate></item><item><title><![CDATA[DMath-u07-bf]]></title><description><![CDATA[ 
 <br><a data-tooltip-position="top" aria-label="sem1/DMath/VRL/V12_" data-href="sem1/DMath/VRL/V12_" href="https://n.ethz.ch/~bfeitknecht/sem1/DMath/VRL/V12_.html" class="internal-link" target="_self" rel="noopener">V12_</a><br><br>Prove that for all positive integers a, b, c:<br>
<br>we define the variables  as products of primes to the powers ,  and  respectively:<br>
<br>this gives us the definitions for gcd(a, b, c) and lcm(a, b, c):<br>
<br>since , ,  are the powers of the prime number  at index  the equation to prove resolves to:<br>
<br>we will prove the equation using case distinction. we only need to concern ourselves with these cases:<br><br><br>If  is less than or equal to both  and , then the minimum of  with anything will be .<br><br>
<br>So, both sides of the equation will be equal.<br><br><br>
If  is greater than or equal to both  and w, then the maximum of   and  will be either  or  (whichever is greater).<br><br>
<br>In both cases, both sides of the equation will be equal.<br><br><br>If  is between  and w, then the maximum of  and w will be , and the minimum of  with  will be .<br><br>
<br>So, both sides of the equation will be equal.<br>Thus, the statement is proven for all  which corresponds to<br>
<br>for all positive integers <br>
<br><br><br>]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/DMath/UE/bf/md/DMath-u07-bf.html</link><guid isPermaLink="false">sem1/DMath/UE/bf/md/DMath-u07-bf.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:21 GMT</pubDate></item><item><title><![CDATA[DMath-u08-bf]]></title><description><![CDATA[ 
 <br><a data-href="V14_körper" href="https://n.ethz.ch/~bfeitknecht/sem1/DMath/VRL/V14_körper.html" class="internal-link" target="_self" rel="noopener">V14_körper</a><br><br>Let  be a group, and let  be a set. Assume that  is a bijection, and consider<br>
<br>
the binary operation  on  given by  

<br>
the unary operation   on  given by .
Prove the following statement.<br>
a) Axiom G1 ( is associative) holds for 

<br><br>To prove that G1 holds for , we will show that the operation  is associative.<br>Let <br>
We need to show that .<br>
Since we have<br>
and<br>
given by the definition of  and the operation  is associative in , we have<br><br><br>Thus,<br>
<br><br><br>c) Prove that .<br> For two groups  and , a function  is called a group homomorphism if, for all  and ,<br>
<br>
If  is a bijection from  to , then it is called an isomorphism, and we say that  and  are isomorphic and write . (Definition 5.10.)<br><br><br><br><br>We define a function  as follows:<br><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>Obviously the function is bijective, as it maps each element onto one unique element (injective) and each element has an inverse (surjective). <br>Now we will prove that it is a group homomorphism on <br>To do this, we must prove, that for all    <br><br>We do this by case distinction:<br><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/DMath/UE/bf/md/DMath-u08-bf.html</link><guid isPermaLink="false">sem1/DMath/UE/bf/md/DMath-u08-bf.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:21 GMT</pubDate></item><item><title><![CDATA[DMath-u09-bf]]></title><description><![CDATA[ 
 <br><br><br>Determine the order and the elements of the group <br><br>: This denotes the set of all positive integers (because of ) less than 36 that are coprime (relatively prime) to 36 (because of ). These are the numbers that do not share any common factors with 36 other than 1.<br>: This denotes the operation on the group, in this case multiplication mod 36.<br>Let's find the elements. The prime factors of 36 are , so we need all numbers less than 36 that don't share these factors.<br> <br>Now let's find the order of each element. The order is defined as follows: , where  is the neutral element in the group,  is an element in the group,  is the smallest positive integer such that the equation holds. In our case we write this as follows: .<br><br>To find the order of the group we simply calculate  using Lemma 5.12.:<br><br>.<br>Thus we have shown that the order of the group is  and the elements are .<br>
<br><br>In this exercise, you prove the remark in Chapter 5, Footnote 20 of the lecture notes. Consider an algebra  such that:<br>i)  is a group.<br>
ii)  is a monoid.<br>
iii)  and  for all .<br>Prove that such an algebra satisfies Definition 5.18 in the lecture notes. Each step should consist of one or more applications of the given axioms, and the axioms used should be made explicit.<br>Hint: consider (1 + 1)(a + b).<br><br><br>Let's consider the case . <br><br>We have proven that the operation  on the algebra  is commutative. The algebra is thus proven to be a ring.<br>Definition 5.18.<br>
A ring  is an algebra for which<br>
(i)  is a (commutative) group<br>
(ii)  is a monoid.<br>
(iii)  and  for all  (left and right distributive laws).<br>
A ring is called commutative if multiplication is commutative (ab = ba)<br>Lemma 5.17.<br>
For any ring , and for all ,<br>
(i) <br>
(ii)<br>
(iii) <br>
(iv) If  is non-trivial (i.e., if it has more than one element), then <br>Definition 5.7.<br>
A group is an algebra  satisfying the following axioms:<br>
G1  is associative.<br>
G2  is a neutral element:  for all <br>
G3 Every  has an inverse element , i.e., <br>Lemma 5.3.<br>
For a group  we have for all :<br>
(i) <br>
(ii)<br>
(iii) Left cancellation law: <br>
(iv) Right cancellation law: <br>
(v) The equation  has a unique solution  for any  and <br>
So does the equation ]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/DMath/UE/bf/md/DMath-u09-bf.html</link><guid isPermaLink="false">sem1/DMath/UE/bf/md/DMath-u09-bf.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:21 GMT</pubDate></item><item><title><![CDATA[DMath-u10-bf]]></title><description><![CDATA[ 
 <br><br>Let <br><br>(a) Prove that  is a field.<br>Proof:<br>
 is a field, since  is prime. (Theorem 5.23.)<br>
Now, since we have shown  to be a field, it remains to show that the polynomial  on  is irreducible (Theorem 5.37.). To do this, we must prove that  has no roots in .<br>
Since<br>
we do this:<br><br>which concludes the proof, as the polynomial  is congruent to zero over no element in the field .<br>
<br><br>(b) Prove that <br>Proof:<br>
To prove that , we need to show two things:<br>
<br>
<br>
Every nonzero element in  can be represented as , where , and  is not congruent to 0. This is because  is irreducible in . Let  be an arbitrary nonzero element in . We need to show that  can be generated by . Consider the polynomial . Notice that  generates the ideal . Therefore, any multiple of  is in . Since  is a multiple of , we can conclude that , and thus, .

<br>
<br>
Consider an arbitrary element  where  and  is not congruent to 0. This element is in . Since  is irreducible,  is nonzero, and thus, . This is because every nonzero element in  can be expressed as . Therefore, .

<br>Combining both steps, we can conclude that , and we have shown that every nonzero element in  can be generated by .<br>
<br><br>(c) Write  as a  product of irreducible polynomials.<br>
Hint: .<br>Proof:<br>
The given polynomial is . Using the hint, we substitute  with :<br><br>Factoring out the common factor :<br><br>Factoring the quadratic  over :<br>
<br>Substituting this back into the expression:<br>
<br>So, the irreducible factorization of    is:<br>
<br>The irreducible polynomials are  , , and .<br>
<br>]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/DMath/UE/bf/md/DMath-u10-bf.html</link><guid isPermaLink="false">sem1/DMath/UE/bf/md/DMath-u10-bf.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:21 GMT</pubDate></item><item><title><![CDATA[DMath-u11-bf]]></title><description><![CDATA[ 
 <br><br>Let  be a proof system. Consider the proof system. , where for all  and  we define<br><br>Prove or disprove the following statements.<br>
a) If  is sound, then  is complete.<br>
b) If  is complete, then  is sound.<br>Through tertium non datur we can assume;<br><br>Definition 6.2.
A Proof System is sound if no false statement has a proof, i.e. for all statements for which there exists a proof  such that the verification function returns true , the statement must be true .
<br>Definition 6.3.
A Proof System is complete if every true statement has a proof, i.e. for all statements  that are true, there exists a proof  such that the verification function returns true .
<br><br>For the scope of this exercise, we assume that  and .<br>If  is sound that means "for all statements  for which there exists a  with  we have ", which is the same as to say that "there does not exist an  with  such that there exists a  with ".<br>Which is the same as to say that "there does not exist an  with  such that there exists a  with ". Since  and  in  are, per definition the opposite of  and  in .<br>Which is to say that "for all  with  there exists a  such that ". All this essentially tells us, that if  is sound, there is no  in  for which  and .<br>So all true statements in  have a proof  for which . Thus, if  is sound  is complete (if we assume ).<br>
<br><br>If we consider  and  to possibly be the empty set, the implication could be disproven by contradiction as follows:<br>
Let  where , ,  and <br>
(Definition of cartesian product between set and empty set implies )
Let  where , ,  and  
<br> is sound, as there is no  such that  (Definition of Sound). Let's assume, for the sake of contradiction, that the implication holds, i.e. for all  there exists a  such that . However, we arrive at a contradiction, as we defined . Thus there exists no  such that  if we consider  to be the empty set. <br><br><br>For the scope of this exercise we again assume that  and .<br>If  is complete that means "for all statements  with  there exists a proof  such that ".<br>Which (per definition) is the same as to say "for all statements  with  there exists a proof  such that  in ".<br>Which gives us no further information on the soundness of the proof system , as all we know is that for all false statements there exists a proof, such that the verification of that statement with that proof is false.<br><br>Let's disprove the implication with a counterexample:<br>
Let  where , ,  and .
Let  where , ,  and .
<br>As we can clearly see,  is complete (per definition of complete) but  is not sound (since there exist a  such that  but , i.e. a false statement has a proof). The implication is thus disproven by counterexample.<br>]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/DMath/UE/bf/md/DMath-u11-bf.html</link><guid isPermaLink="false">sem1/DMath/UE/bf/md/DMath-u11-bf.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:21 GMT</pubDate></item><item><title><![CDATA[DMath-u12-bf]]></title><description><![CDATA[ 
 <br><br>We extend predicate logic with a new quantifier  (read: for many) as follows:<br>Syntax: If  is a formula, then for any variable symbol ,  is a formula.<br>
Semantics: .<br>Using the semantics of predicate logic extended in this way, prove or disprove the following statements, where  is an arbitrary formula.<br>a) The formula  is unsatisfiable.<br>
b) <br>
c) <br>Expectation: If the statement is true, your proof should use the definitions of the semantics. In each step, at most one definition (e.g., the semantics of ) should be applied. If the statement is not true, you should provide a counterexample: make sure to define everything needed for a suitable interpretation.<br><br>a) The formula  is unsatisfiable.<br>Disproven by counterexample. We want to show that there exists an interpretation  such that , making the formula satisfiable.<br>Let  be the formula <br>Let  be a suitable interpretation for the formula.<br>
<br>Let 
<br>Let  (there are no functions in our formula)
<br>Let 
<br>Let  (there are no free variables in our formula)
<br><br>All that remains is to show is that  and .<br>We define two sets  and  and construct a bijection between them and <br>
Let  be defined as . It's easy to see that, for every .<br>
Let  be defined as . Since, for every  as  for all .<br>Thus both parts are satisfiable under some interpretation , disproving the statement.<br>
<br><br>b) <br>We proof this by showing that any interpretation that's suitable for both sides of the formula and is a model for  is also a model for .<br>Since any  (where  is a model for the LHS) is equinumerous to the set  and no  can be empty (as per Definition 6.34.), that same  is also a model for , by definition 6.36. <br><br>As was to be shown.<br>
<br><br>c) <br>We will disprove this statement with a counterexample.<br>Let  be the formula <br>Let  be a suitable interpretation for the formula.<br>
<br>Let 
<br>Let  (there are no functions in our formula)
<br>Let 
<br>Let  (there are no free variables in our formula)
<br><br><br>What this is saying in words is, that our chosen interpretation  is a model for the LHS (since, for all natural numbers , there is a set of numbers  equinumerous to the set of natural nubers () that is larger than than ) but not a model for the RHS (since, not for every number  all numbers  are larger than that number). <br>We have shown there exists some interpretation  that is suitable for both sides of the formula and is a model for  but not for .<br>
]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/DMath/UE/bf/md/DMath-u12-bf.html</link><guid isPermaLink="false">sem1/DMath/UE/bf/md/DMath-u12-bf.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:21 GMT</pubDate></item><item><title><![CDATA[V00_DMath]]></title><description><![CDATA[ 
 ]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/DMath/VRL/V00_DMath.html</link><guid isPermaLink="false">sem1/DMath/VRL/V00_DMath.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:21 GMT</pubDate></item><item><title><![CDATA[V01_mathematical propositions]]></title><description><![CDATA[ 
 <br>Mathematische Aussage:<br>
<br>
"91 ist eine Primzahl."

<br>Vermutung? Theorem? Lemma?
<br>Verstehen wir, was die Aussage aussagt?
<br>Ist die Aussage wahr oder falsch?
<br>Wann ist sie wahr, wann falsch?
<br>7*13=91 –&gt; 91 ist keine Primzahl –&gt; also ist die Aussage nicht wahr


<br>
"Vögel können fliegen."

<br>Mathematische Aussage? Nein


<br>
"Egal welches Feld eines 8x8 Bretts, der Rest ist durch eine L-Form abdeckbar."

<br>Verstehen wir die Aussage? Ja
<br>P(k) = 1 &lt;=&gt; "Für jede Position im k*k Quadrat die markiert ist, existiert eine Zerlegung des Restfelds."
<br>"Für jede" &lt;=&gt; 
<br>"existiert" &lt;=&gt; 


<br>
Es gibt Aussagen, bei denen klar ist, wie deren Wahrheit beweisbar ist.<br>
Es gibt Aussagen, bei denen nicht klar ist, wie deren Unwahrheit beweisbar ist.
<br>
<br>
P(2)=1

<br>2*2=4, 4-1=3, 3%3=0
<br>4-1 ist 3, 3 ist ohne rest durch 3 teilbar, also ist die Aussage nicht wahr beweisbar 


<br>
P(3)=0

<br>3*3=9, 9-1=8, 8 % 3 != 0
<br>9-1 ist 8, was nicht ohne Rest durch 3 teilbar ist, also ist die Aussage nicht wahr 


<br>
k^2 % 3 != 1 –&gt; P(k)=0

<br>
wenn das Quadrat von k minus eins nicht ohne Rest durch drei teilbar ist, so ist P(k)=0.

<br>
Theorem: P(k)=1 =&gt; P(2k)=1 (RHS ist Implikation von LHS)

<br>
Beweis: (nicht von LHS sondern nur Implikation daraus, also LHS)

<br>Rekursion ermöglicht Zerlegung in Viertel, Wählen der markierten Felder um die Mitte, L


<br>
Aufgabenstellung: Auf einem 8x8 Feld aus Quadraten wird ein Feldabgedeckt. Existiert eine Konfiguration an Anordnungen von L-förmigen Formen, bestehend aus drei Häuschen, bei dem das gesamte Brett ohne Überlappung abgedeckt wird.
<br> Für jede () Markierung existiert () eine Zerlegung des Restfeldes <br><br>
 <br>
<br>
<br>Theorem:  (Rekursiver Algorithmus)<br><br>
Aufgabenstellung: Eine Schweizer Schokolade besteht aus 6 Reihen und 4 Stücken pro Reihe. Wir möchten es in 24 Stücke brechen mit der minimalen Anzahl an Operationen des Brechens.
<br>
Abstraktion: Jeder Bruch produziert ein weiteres Stück, deshalb braucht es sowieso 24 Brüche um 24 Stücke zu erzeugen.
<br><br>
Aufgabenstellung: Man kann die Form 1.6 in 8 gleiche Teile einteilen, kann man sie in 9 gleiche Stücke einteilen.
<br>
Abstraktion:
]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/DMath/VRL/V01_mathematical propositions.html</link><guid isPermaLink="false">sem1/DMath/VRL/V01_mathematical propositions.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:21 GMT</pubDate></item><item><title><![CDATA[V02_propositions, logical operators]]></title><description><![CDATA[ 
 <br><br>**Aussagen:<br>
<br>R = 2^143 ist keine Primzahl
<br>S = 5 ist gerade (falsch)
<br>T = 71 ist eine Primzahl (wahr)
<br>U = 25 ist eine Quadratzahl (wahr)
<br>V = S &amp; T (falsch)
<br>W = S | T (wahr)
<br>X = S ist falsch (wahr)
<br>Y = S =&gt; T (implikation, wahr)
<br>Aussage:<br>
1 &lt; 0<br>Beweis:<br>
1 &lt; 0 =&gt; 2 &lt; 1 (+1 auf beiden Seiten)<br>
=&gt; 2*1 &gt; 1*1 (multiplikation mit negativen Zahlen „dreht“ Ungleichheit um)<br>
=&gt; 2 &gt; 1<br>
falsch, weil Aussage ist Teil des Beweises<br>S =&gt; T und T wahr<br>A = X hat Masern<br>
B = X hat Windpocken (WP)<br>
C = X hat Lungenentzündung (LE)<br>F = X hat Masern oder (WP und LE)<br>F : A  (B  C)<br>
G : B  (A  C)<br>
H : A  (A  B  C)<br>-&gt; steht zwischen Formeln<br>
=&gt; steht zwischen Aussagend<br>F  H  H (): unerfüllbare Formel<br>
F  G (): immer erfüllte Formel (Tautologie)<br>Aussage: F  G  A (wahr)<br>H  I def. H  I und I  H<br>
zwei Formeln sind equivalent, wenn ihre Wahrheitstabellen für alle Werte gleich sind.<br>
A  B  A  B]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/DMath/VRL/V02_propositions, logical operators.html</link><guid isPermaLink="false">sem1/DMath/VRL/V02_propositions, logical operators.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:21 GMT</pubDate></item><item><title><![CDATA[V03_predicates]]></title><description><![CDATA[ 
 <br><br>
man kann S beweisen, indem<br>
1. eine Aussage R formulieren<br>
2. R beweisen<br>
3. RS beweisen
A(AB)  B
<br>Lemma 2.1
5. erstes Distributivgesetz<br>
A(BC)  (AB)(AC)
<br>Definition von 
A(BB)  (AB) (Definition von )<br>
 (AA)  (AB) (Lemma 2.1, 5.)<br>
   (AB)<br>
 AB
<br>^^^^^^^^^^^^^^^^^^^^^^^^<br>
bis Skript 2.3<br><br>x (x+3 &lt; x+5)<br><br>add(x, y)<br>
mult(x, y)<br><br>less(x, y) is true when x&lt;y<br>
equal(x, y) is true when x=y<br>
prime(x) is true when x is prime<br>
divides(x, y) def.:  u, equal(mult(x, u), y)]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/DMath/VRL/V03_predicates.html</link><guid isPermaLink="false">sem1/DMath/VRL/V03_predicates.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:21 GMT</pubDate></item><item><title><![CDATA[V04_logical formulas]]></title><description><![CDATA[<a class="tag" href="https://n.ethz.ch/~bfeitknecht/?query=tag:Prädikat" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Prädikat</a> <a class="tag" href="https://n.ethz.ch/~bfeitknecht/?query=tag:Informelle-Äquivalenz" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Informelle-Äquivalenz</a> <a class="tag" href="https://n.ethz.ch/~bfeitknecht/?query=tag:Transitivität" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Transitivität</a> 
 <br><br>Prädikate:
Es gibt eine kleinste Zahl.<br>

Es gibt nicht für jede Zahl eine (noch) kleinere.<br>

Formeln sind äquivalent.
<br>Universum: U | U=<br>
Prädikate: P, Q, P(x), Q(x, y) | , prime, even<br>
Funktionen: f, g f(x), g(x, y) | +, -<br>
Konstanten: a, b, c | 0, 1, 2, 3<br>
Formeln: <br>Eine Formel an sich ist nicht wahr oder falsch, es kommt auf die Interpretation an.<br><br> prime(x)<br>prime(35) = 1  1<br><br><br>
Durch Äquivalenz-transformation <br><br>]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/DMath/VRL/V04_logical formulas.html</link><guid isPermaLink="false">sem1/DMath/VRL/V04_logical formulas.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:21 GMT</pubDate></item><item><title><![CDATA[V05_equivalence transformations]]></title><description><![CDATA[ 
 <br>Two ways to understand<br>
<br>
<br>
w/o interpretation (universe, predicates, what is equal?):<br>
<br>


<br>
with interpretation:<br>
every number that is not zero has a multiplicative inverse<br>
valid (Q, R)<br>
invalid (N, Z)

<br>
<br>

<br>

<br>Definitions:
"": F is true if P() and Q() for some (same) <br>
Then there's an x() so that P(x) true<br>
and an x() so that Q(x) true
"": Let U=, P(x)  even(x), Q(x) odd(x)<br>
Then G is true but F isn't.
<br>
<br>


<br>


<br>


<br>


<br>


<br>


<br>


<br>


<br>
F tautology  

<br>


<br>
 [Def. ]

<br>
 [2.4.8]

<br>
 [Ch. 6]

<br>


<br>


<br>Just a formula, not a statement:
 (true) statement<br>
(false statement) for 
<br>Composition of 
If  and  are true, we condclude  true as well.<br>
Proof: 
Variants: 
<br>Direct proof of 
To prove : assume  is true, then prove  under this assumption.<br>
i.e.: If , then  square.<br>
<br>
 [assumption]<br>
 [associativity, commutivity]<br>
 [w=u, v]
]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/DMath/VRL/V05_equivalence transformations.html</link><guid isPermaLink="false">sem1/DMath/VRL/V05_equivalence transformations.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:21 GMT</pubDate></item><item><title><![CDATA[V06_lemmas, mengen]]></title><description><![CDATA[<a class="tag" href="https://n.ethz.ch/~bfeitknecht/?query=tag:Mengen-Lehre" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Mengen-Lehre</a> 
 <br> beweisen, indem man<br>
 beweist.<br>Lemma: 
x irrational   irrational<br>
 rational (T falsch)   (Def. von rational)<br>
 (Gleichung quadrieren)<br>
<br>
 (Def. rational)
<br>Lemma: 
<br>

<br>Lemma: 
<br>
<br>

Bsp. S: <br>
<br>
 m, n sind teilerfremd: ggT(m, n) = 1<br>
<br>

<br><br>
<br>
<br>Induktion
<br>
Theorem:<br>
<br>
<br>

<br><br>{{1}} = {1} ?<br>Russell<br>
<br>
<br>
<br>
-&gt; Paradox!<br>Geht nicht, weil Universum aller Mengen ist keine Menge<br>]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/DMath/VRL/V06_lemmas, mengen.html</link><guid isPermaLink="false">sem1/DMath/VRL/V06_lemmas, mengen.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:21 GMT</pubDate></item><item><title><![CDATA[V08_relations]]></title><description><![CDATA[ 
 <br> (S, F)-Relation<br>
<br>
<br>
<br>definition einer relations inverse<br>
<br>
<br>
<br><br>]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/DMath/VRL/V08_relations.html</link><guid isPermaLink="false">sem1/DMath/VRL/V08_relations.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:21 GMT</pubDate></item><item><title><![CDATA[V10_posets]]></title><description><![CDATA[ 
 <br>a poset is a partially ordered set, a tuple (S; R) such that <br>blabla]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/DMath/VRL/V10_posets.html</link><guid isPermaLink="false">sem1/DMath/VRL/V10_posets.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:21 GMT</pubDate></item><item><title><![CDATA[V11_]]></title><description><![CDATA[<a class="tag" href="https://n.ethz.ch/~bfeitknecht/?query=tag:Injektion" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Injektion</a> 
 <br><br>A ~ B def.: es gibt eine bijektion von A  B und B  A ]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/DMath/VRL/V11_.html</link><guid isPermaLink="false">sem1/DMath/VRL/V11_.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:21 GMT</pubDate></item><item><title><![CDATA[V12_]]></title><description><![CDATA[ 
 <br><br>
<br>
^^^^^^^^^^^Ring<br><br>
<br>
<br>
<br>
]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/DMath/VRL/V12_.html</link><guid isPermaLink="false">sem1/DMath/VRL/V12_.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:21 GMT</pubDate></item><item><title><![CDATA[V13_]]></title><description><![CDATA[ 
 <br>where:<br>
<br><br><br>weil, entweder , oder  macht  falsch, in diesem fall kann für    gewählt werden, was  wahr macht.<br><br>]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/DMath/VRL/V13_.html</link><guid isPermaLink="false">sem1/DMath/VRL/V13_.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:21 GMT</pubDate></item><item><title><![CDATA[V14_körper]]></title><description><![CDATA[<a class="tag" href="https://n.ethz.ch/~bfeitknecht/?query=tag:homomorphismus" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#homomorphismus</a> <a class="tag" href="https://n.ethz.ch/~bfeitknecht/?query=tag:Ring" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Ring</a> 
 <br><br>2 dimensionaler plan von 3d raum, es kommt nicht drauf an, ob zuerst x plus y komponente für vektor und dann z komponente auf 0 oder zuerst z komponente auf 0 und dann x + y vektoren addieren.<br>determinante einer matrix matrix auf reele zahlen<br><br>
<br>
<br>
=<br>
<br>euler theorem:<br>
a: teilerfremde zahl zu m<br><br>
<br>|H| teilt |G|<br>
&lt;a&gt; ist Untergruppe<br>
|&lt;a&gt;| = ord(a)<br>
|&lt;a&gt;| teilt |G|<br>
a^|G| = e<br><br>
<br>
<br>
<br>
<br><br> <br>
<br> ist (abelische) Gruppe 
<br> ist Monoid
<br>a(b+c) = ab+ bc<br>
(b+c)a = ba + ca -&gt; links, und rechts distributiv
<br>Ring = kommutativ wenn multiplikation kommutativ ist<br>
wenn ein abelischer monoid existiert<br>R x R<br>
def +: (a, b) + (a', b') = (a + a', b + b')<br>
def : (a, b)  (a', b') = (bb' - aa', ab' + a'b)<br>Körper ist kommutativer ring, bei dem jedes element ausser null invertierbar ist]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/DMath/VRL/V14_körper.html</link><guid isPermaLink="false">sem1/DMath/VRL/V14_körper.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:21 GMT</pubDate></item><item><title><![CDATA[V15_]]></title><description><![CDATA[<a class="tag" href="https://n.ethz.ch/~bfeitknecht/?query=tag:Quaternions" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Quaternions</a> 
 <br><br>Nicht kommutativ!]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/DMath/VRL/V15_.html</link><guid isPermaLink="false">sem1/DMath/VRL/V15_.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:21 GMT</pubDate></item><item><title><![CDATA[EProg]]></title><description><![CDATA[ 
 ]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/EProg/lib/EProg.html</link><guid isPermaLink="false">sem1/EProg/lib/EProg.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:21 GMT</pubDate></item><item><title><![CDATA[EProg_lib]]></title><description><![CDATA[ 
 ]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/EProg/lib/EProg_lib.html</link><guid isPermaLink="false">sem1/EProg/lib/EProg_lib.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:21 GMT</pubDate></item><item><title><![CDATA[EProg-u01-bf]]></title><description><![CDATA[ 
 <br><br><br>Erstellen Sie eine Beschreibung geradezahl, die als legale Symbole alle geraden Zahlen (d.h. Zahlen, die ohne Rest durch 2 teilbar sind) zulässt. Beispiele sind +02, 4, 10, -20.<br>solution
sign &lt;= + | -<br>
digit &lt;= [ 0 | 1 | 2 | 3&nbsp;|&nbsp;4 |&nbsp;5 | 6 | 7 | 8 | 9 ]<br>
even_digit &lt;= 2 | 4 | 6 | 8<br>
zero &lt;= 0<br>
geradezahl &lt;= [ sign ] { digit } even_digit [ zero ]
<br><br>Zeigen Sie in einer Tabelle, dass Ihre Beschreibung das Symbol “28” als gerade Zahl erkennt.<br>solution
option: sign:<br>
(1) wiederholung: option: digit: 2<br>
even_digit: 8<br>
option: zero
<br><br>Erstellen Sie eine Beschreibung &lt;x2ygemischt&gt; , die als legale Symbole genau jene Wörter zulässt, in denen für jedes “X” zwei “Y” als Paar auftreten. Beispiele sind XYY, YYX, XYYYYX, XXYYYY.<br>solution

x2ygemischt &lt;= (X [x2ygemischt] YY) | (YY [x2ygemischt] X)

<br><br>Die folgenden EBNF-Beschreibungen sind nicht äquivalent. Finden Sie ein kürzestmögliches Symbol, das von der einen Beschreibung als legal erkannt wird, aber nicht von der anderen. <br>solution
beispiel1 &lt;= [ A ] [ B ]<br>
beispiel2 &lt;= [ A [ B ] ]
beispiel1<br>
option(A):<br>
option(B): B<br>
beispiel1: B
beispiel2<br>
option(A(option(B)):<br>
option(B) nicht möglich ohne option: A
<br><br>Erstellen Sie eine EBNF Beschreibung &lt;doppelt&gt; , die als legale Symbole genau jene Wörter zulässt, in denen die doppelte Anzahl “Y” nach einer Folge von “X” auftritt. Beispiele sind XYY, XXYYYY, usw.<br>solution
doppelt &lt;= X [{doppelt}] YY
]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/EProg/UE/bf/EProg-u01-bf.html</link><guid isPermaLink="false">sem1/EProg/UE/bf/EProg-u01-bf.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:21 GMT</pubDate></item><item><title><![CDATA[EProg-u02-bf]]></title><description><![CDATA[ 
 <br>// SwissFlag.java]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/EProg/UE/bf/EProg-u02-bf.html</link><guid isPermaLink="false">sem1/EProg/UE/bf/EProg-u02-bf.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:21 GMT</pubDate></item><item><title><![CDATA[V00_EProg]]></title><description><![CDATA[ 
 ]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/EProg/VRL/V00_EProg.html</link><guid isPermaLink="false">sem1/EProg/VRL/V00_EProg.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:21 GMT</pubDate></item><item><title><![CDATA[V01_EBNF]]></title><description><![CDATA[<a class="tag" href="https://n.ethz.ch/~bfeitknecht/?query=tag:Kontrollelemente" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Kontrollelemente</a> <a class="tag" href="https://n.ethz.ch/~bfeitknecht/?query=tag:EBNF" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#EBNF</a> <a class="tag" href="https://n.ethz.ch/~bfeitknecht/?query=tag:EBNF-Beschreibung" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#EBNF-Beschreibung</a> <a class="tag" href="https://n.ethz.ch/~bfeitknecht/?query=tag:EBNF-Regeln" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#EBNF-Regeln</a> 
 <br><br>
<br>Aufreihung - Sequence
<br>Entscheidung - Decision
<br>Wiederholung - Repetition
<br>Rekursion - Recursion
<br><br>Extended Backus (Forscher) Naur (Forscher) Form<br>
<br>Beschreibt die Syntax einer Sprache

<br>Liefert eine Menge von Symbolen - Konstruktion
<br>Erlaubt die Prüfung von Symbolen - Verifikation


<br><br>Menge von EBNF Regeln wobei die Reihenfolge unwichtig ist.<br><br>LHS (Left Hand Side)  RHS (Right Hand Side)<br>RHS: Wert
 zero  0<br>
one  1
<br>RHS: EBNF Name
 null  zero<br>
eins  one
<br>RHS: Kontrollelemente

 one  zero  one<br>
ten  one  zero

dig  0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9  | = or<br>
bin  one | zero  | = or
abc1  a (b | c)  () = and<br>
abc2  (a b) | c  () = and<br>
abc1  abc2
init1  B [A] R   [] = optional<br>
init2  B (A | ) R   = nothing<br>
init1 = init2
]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/EProg/VRL/V01_EBNF.html</link><guid isPermaLink="false">sem1/EProg/VRL/V01_EBNF.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:21 GMT</pubDate></item><item><title><![CDATA[V02_EBNF+]]></title><description><![CDATA[<a class="tag" href="https://n.ethz.ch/~bfeitknecht/?query=tag:EBNF" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#EBNF</a> <a class="tag" href="https://n.ethz.ch/~bfeitknecht/?query=tag:EBNF-Regeln" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#EBNF-Regeln</a> <a class="tag" href="https://n.ethz.ch/~bfeitknecht/?query=tag:EBNF-Beschreibung" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#EBNF-Beschreibung</a> <a class="tag" href="https://n.ethz.ch/~bfeitknecht/?query=tag:EBNF-Verifizierung" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#EBNF-Verifizierung</a> <a class="tag" href="https://n.ethz.ch/~bfeitknecht/?query=tag:EBNF-Äquivalent" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#EBNF-Äquivalent</a> <a class="tag" href="https://n.ethz.ch/~bfeitknecht/?query=tag:Mengen-Äquivalent" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Mengen-Äquivalent</a> <a class="tag" href="https://n.ethz.ch/~bfeitknecht/?query=tag:Syntax-Semantik" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Syntax-Semantik</a> 
 <br><br><br>RHS: EBNF Kontrollelemente

ones  {1}  .. Wiederholungen<br>
zeros  {0}  .. Wiederholungen<br>
digits  digit {digit}  .. Wiederholungen<br>
integer  [+|-] digits
<br><br>Einfache (ganze) Sprache mit <br>
<br>unwichtiger Reihenfolge (Konvention Einfach  Komplex)
<br>unwichtigem Namen (Namen sind exklusiv und gehören nur zu einer Regel)
<br><br>Symbol legal gemäss einer Regel: Alle Zeichen des Symbols stimmen mit den Elementen der Regel überein.<br>
<br>Selbe Zeichen
<br>Selbe Reihenfolge
<br><br>
<br>Links  Rechts
<br>Zeichen für Zeichen
<br>Keine Übrigen Elemente der Regel
<br>Keine Übrigen Symbole
<br>EBNF Verifizierung
digit: 6 Legal | 66 Illegal<br>
[opperation] digit: +6 Legal | 6 Legal | -6 Legal | 66 Illegal
<br><br>
<br>Ersetze einen Namen LHS durch die Regel RHS und vereinfache
<br>EBNF Verifizierung Formal
Integer  [+|-] digit {digit}  + 128<br>
Integer  [+] digit {digit}  + 128<br>
Integer  + digit {digit}  + 128<br>
Integer  + 1 {digit}  + 128<br>
Integer  + 1 2 {digit}  + 128<br>
Integer  + 1 2 8  + 128
<br>
<br>Ableitungsbaum
<br>EBNF Verifizierung Formal
"Mermaid Tree Diagram ep_V2"
<br><br>Wenn wir ein Sonderzeichen als normales Zeichen in eine EBNF Regel integrieren möchten muss es mit einer Box umrandet werden.<br>
<br><br>EBNF Regeln sind gleichwertig wenn sie in jedem Kontext gleich sind. Äquivalente EBNF-Beschreibungen erkennen die gleichen legalen und illegalen Symbole.<br><br><br>Mengen sind gleichwertig wenn sie die gleichen Elemente enthalten. äquivalente Mengen müssen nicht die gleiche Reihenfolge oder nicht die gleiche Anzahl an gleichen Elementen aufweisen.<br><br><br>
<br>Syntax: Beschreibt die Sprache um die Form fest zu legen mit bestimmten Regeln.
<br>Semantik: Beschreibt die Bedeutung die vom Syntax ausgedrückt wird.
<br>EBNF-Beschreibungen machen ausschliesslich Aussagen zum Syntax.<br><br><br><br>]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/EProg/VRL/V02_EBNF+.html</link><guid isPermaLink="false">sem1/EProg/VRL/V02_EBNF+.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:21 GMT</pubDate></item><item><title><![CDATA[V03_methoden, pre- & post-conditions]]></title><description><![CDATA[ 
 ]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/EProg/VRL/V03_methoden, pre- &amp; post-conditions.html</link><guid isPermaLink="false">sem1/EProg/VRL/V03_methoden, pre- &amp; post-conditions.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:21 GMT</pubDate></item><item><title><![CDATA[V04_typen und variablen]]></title><description><![CDATA[ 
 ]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/EProg/VRL/V04_typen und variablen.html</link><guid isPermaLink="false">sem1/EProg/VRL/V04_typen und variablen.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:21 GMT</pubDate></item><item><title><![CDATA[V05_verzweigungen, schleifen]]></title><description><![CDATA[ 
 ]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/EProg/VRL/V05_verzweigungen, schleifen.html</link><guid isPermaLink="false">sem1/EProg/VRL/V05_verzweigungen, schleifen.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:21 GMT</pubDate></item><item><title><![CDATA[V06_]]></title><description><![CDATA[ 
 <br>class main
	public static void main (String[] args) {
		System.out.println()
	}
Copy]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/EProg/VRL/V06_.html</link><guid isPermaLink="false">sem1/EProg/VRL/V06_.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:21 GMT</pubDate></item><item><title><![CDATA[LinAlg]]></title><description><![CDATA[ 
 ]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/LinAlg/lib/LinAlg.html</link><guid isPermaLink="false">sem1/LinAlg/lib/LinAlg.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:22 GMT</pubDate></item><item><title><![CDATA[LinAlg_lib]]></title><description><![CDATA[ 
 ]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/LinAlg/lib/LinAlg_lib.html</link><guid isPermaLink="false">sem1/LinAlg/lib/LinAlg_lib.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:22 GMT</pubDate></item><item><title><![CDATA[LinAlg_U1_bf]]></title><description><![CDATA[ 
 ]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/LinAlg/UE/bf/md/LinAlg_U1_bf.html</link><guid isPermaLink="false">sem1/LinAlg/UE/bf/md/LinAlg_U1_bf.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:22 GMT</pubDate></item><item><title><![CDATA[V00_LinAlg]]></title><description><![CDATA[ 
 ]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/LinAlg/VRL/V00_LinAlg.html</link><guid isPermaLink="false">sem1/LinAlg/VRL/V00_LinAlg.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:22 GMT</pubDate></item><item><title><![CDATA[V01_linear combinations]]></title><description><![CDATA[ 
 <br>linear combinations, scalar multiplications]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/LinAlg/VRL/V01_linear combinations.html</link><guid isPermaLink="false">sem1/LinAlg/VRL/V01_linear combinations.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:22 GMT</pubDate></item><item><title><![CDATA[V02_scalar products]]></title><description><![CDATA[ 
 ]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/LinAlg/VRL/V02_scalar products.html</link><guid isPermaLink="false">sem1/LinAlg/VRL/V02_scalar products.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:22 GMT</pubDate></item><item><title><![CDATA[V03_matrix multiplication]]></title><description><![CDATA[ 
 ]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/LinAlg/VRL/V03_matrix multiplication.html</link><guid isPermaLink="false">sem1/LinAlg/VRL/V03_matrix multiplication.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:22 GMT</pubDate></item><item><title><![CDATA[V12_]]></title><description><![CDATA[<a class="tag" href="https://n.ethz.ch/~bfeitknecht/?query=tag:Skalarprodukt" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Skalarprodukt</a> <a class="tag" href="https://n.ethz.ch/~bfeitknecht/?query=tag:Norm" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Norm</a> 
 <br><br><br><br>
 &lt;–– x orthogonal y<br><br><br>
<br>4 Fundamentale SP<br>
<br>
<br>
<br>
<br>some more interesting things:<br>
<br>
<br>
<br>
]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/LinAlg/VRL/V12_.html</link><guid isPermaLink="false">sem1/LinAlg/VRL/V12_.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:22 GMT</pubDate></item><item><title><![CDATA[V14_Orthonormale Basis]]></title><description><![CDATA[<a class="tag" href="https://n.ethz.ch/~bfeitknecht/?query=tag:Orthonormal-Basis" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Orthonormal-Basis</a> <a class="tag" href="https://n.ethz.ch/~bfeitknecht/?query=tag:Gram-Schmidt-Algorithm" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Gram-Schmidt-Algorithm</a> <a class="tag" href="https://n.ethz.ch/~bfeitknecht/?query=tag:Normal-Gleichungen" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Normal-Gleichungen</a> 
 <br><br><br><br>
<br><br><br>]]></description><link>https://n.ethz.ch/~bfeitknecht/sem1/LinAlg/VRL/V14_Orthonormale Basis.html</link><guid isPermaLink="false">sem1/LinAlg/VRL/V14_Orthonormale Basis.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:22 GMT</pubDate></item><item><title><![CDATA[Analysis-1]]></title><description><![CDATA[ 
 <br>Analysis ist die Lehre von kontinuierlichem Shit.<br>
<br>slope of a curve, area under a curve...
<br>sometimes hard continual problems can be approximatively solved using simple discrete problem
<br>i.E. linear programming vs integer programming, numeric method to solve differential equations
]]></description><link>https://n.ethz.ch/~bfeitknecht/sem2/Analysis-1/VRL/notes/Analysis-1.html</link><guid isPermaLink="false">sem2/Analysis-1/VRL/notes/Analysis-1.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:22 GMT</pubDate></item><item><title><![CDATA[AuW]]></title><description><![CDATA[ 
 <br>Why probability? RANDOMNESS!!
Makes a lot of stuff faster, more secure (polynomial prime test, simultaneous connection problem, O(1) hash tables).
<br>-zusammenhängend
Sei  ein Graph. G ist -zusammenhängend, wenn gilt:<br>
- <br>
- : jeder u-v-Seperator  hat Grösse 
<br>Satz von Menger
Sei  ein Graph. Dann gilt:
G ist -zusammenhängend   gibt es  intern-knotendisjunkte u-v Pfade.
]]></description><link>https://n.ethz.ch/~bfeitknecht/sem2/AuW/VRL/notes/AuW.html</link><guid isPermaLink="false">sem2/AuW/VRL/notes/AuW.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Tue, 20 Feb 2024 14:22:25 GMT</pubDate></item><item><title><![CDATA[Digitec]]></title><description><![CDATA[ 
 ]]></description><link>https://n.ethz.ch/~bfeitknecht/sem2/DDCA/VRL/notes/Digitec.html</link><guid isPermaLink="false">sem2/DDCA/VRL/notes/Digitec.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:22 GMT</pubDate></item><item><title><![CDATA[PProg]]></title><description><![CDATA[ 
 ]]></description><link>https://n.ethz.ch/~bfeitknecht/sem2/PProg/VRL/notes/PProg.html</link><guid isPermaLink="false">sem2/PProg/VRL/notes/PProg.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:22 GMT</pubDate></item><item><title><![CDATA[AuD-topics]]></title><description><![CDATA[ 
 <br>]]></description><link>https://n.ethz.ch/~bfeitknecht/var/sem1-exam-prep/AuD-topics.html</link><guid isPermaLink="false">var/sem1-exam-prep/AuD-topics.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:21 GMT</pubDate></item><item><title><![CDATA[LinAlg-topics]]></title><description><![CDATA[ 
 <br>]]></description><link>https://n.ethz.ch/~bfeitknecht/var/sem1-exam-prep/LinAlg-topics.html</link><guid isPermaLink="false">var/sem1-exam-prep/LinAlg-topics.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:21 GMT</pubDate></item><item><title><![CDATA[literature2buy?]]></title><description><![CDATA[ 
 <br>AuD<br>
<br>Ronald L. Graham, Donald E. Knuth, and Oren Patashnik. 1994. Concrete Mathematics: A Foundation for Computer Science (2nd ed.). Addison-Wesley Longman Publishing Co.
<br>Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. 2009. Introduction to Algorithms (3rd ed.). MIT Press.
<br>EProg<br>
<br>S. Reges und M. Stepp, "Building Java Programs",&nbsp; Pearson.&nbsp; 5. Auflage (2019) aber die 4. Auflage (2016) geht genauso gut. Einige Beispiele aus der Vorlesung finden Sie auch in diesem Buch. Die Informatik Bibilothek hat Exemplare.
<br>R. Sedgewick und K. Wayne, "Einführung in die Programmierung mit Java", 2011, Pearson Higher Education, ISBN 978-3-86894-0476-3. Deutsche Übersetzung, auch auf Englisch (neuere Ausgabe!) erhältlich. &nbsp;Enthält viele interessante Beispiele von Programmen die Anwendungsprobleme lösen. Auch in der Informatik Bibliothek vorhanden.
<br>var<br>
<br>the art of computer programming, knuth
<br>SICP
<br>the c programming language
<br>design patterns in oop
<br>the dragon book
<br>the wizard book
<br>the mythical man moth
<br>the design of everyday things
]]></description><link>https://n.ethz.ch/~bfeitknecht/var/sem1-exam-prep/literature2buy/literature2buy.html</link><guid isPermaLink="false">var/sem1-exam-prep/literature2buy?.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:22 GMT</pubDate></item><item><title><![CDATA[prüfungsvorbereitung]]></title><description><![CDATA[ 
 <br><a data-href="var" href="https://n.ethz.ch/~bfeitknecht/var/var.html" class="internal-link" target="_self" rel="noopener">var</a><br>LinAlg:<br>
eng/ger<br>
6 A4-Seiten Notizen oder 3 doppelseitige A4 Notizen (mit LaTeX oder Ähnlichem erfasste und gedruckte Notizen sind erlaubt; sie sollten ohne Lupe lesbar sein); ein Wörterbuch (Deutsch-Englisch oder andere Fremdsprache); kein Taschenrechner.<br>DMath:<br>
ger<br>
Selbstverfasste, handgeschriebene Notizen auf 6 A4-Seiten (respektive 3 Blätter doppelseitig).<br>AuD:<br>
ger<br>
keine<br>EProg:<br>
ger<br>
keine]]></description><link>https://n.ethz.ch/~bfeitknecht/var/sem1-exam-prep/prüfungsvorbereitung.html</link><guid isPermaLink="false">var/sem1-exam-prep/prüfungsvorbereitung.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:22 GMT</pubDate></item><item><title><![CDATA[var]]></title><description><![CDATA[ 
 <br><a data-href="sem1" href="https://n.ethz.ch/~bfeitknecht/sem1" class="internal-link" target="_self" rel="noopener">sem1</a><br>notes from the first day: <a data-href="ersti tag" href="https://n.ethz.ch/~bfeitknecht/ersti tag" class="internal-link" target="_self" rel="noopener">ersti tag</a> <br>schedule: <a data-href="sem1_schedule.jpg" href="https://n.ethz.ch/~bfeitknecht/sem1_schedule.jpg" class="internal-link" target="_self" rel="noopener">sem1_schedule.jpg</a><br>consider buying the following books:<a data-href="literature2buy?" href="https://n.ethz.ch/~bfeitknecht/var/sem1-exam-prep/literature2buy?.md" class="internal-link" target="_self" rel="noopener">literature2buy?</a>]]></description><link>https://n.ethz.ch/~bfeitknecht/var/var.html</link><guid isPermaLink="false">var/var.md</guid><dc:creator><![CDATA[Basil Feitknecht]]></dc:creator><pubDate>Mon, 19 Feb 2024 18:43:22 GMT</pubDate></item></channel></rss>